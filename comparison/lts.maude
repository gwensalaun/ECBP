---- authors: Francisco Duran and Gwen Salaun
---- file: lts.maude
----
---- This file contains the definitions for the representation of LTS models

sload identifier.maude

---- States ------------------------------------------------------------------
fmod STATE is
  pr IDENTIFIER .
  pr NAT .

  sort State . 
----  op state : Id -> State [ctor] .
  op state : Nat -> State [ctor] .
endfm

view State from TRIV to STATE is
  sort Elt to State .
endv

---- Transitions ----------------------------------------------------------
fmod TRANSITION is
  pr STATE .

  sort Transition .
  op transition : State Id State -> Transition [ctor] .
endfm

view Transition from TRIV to TRANSITION is
  sort Elt to Transition .
endv

---- LTS ----------------------------------------------------------------
omod LTS is
  pr SET{State} .
  pr SET{Transition} .
  pr SET{Id} .
  pr CONVERSION .
  pr MAP{State, Nat} .

  subsort Id < Oid . ---- PIds are valid object ids

  ---- LTS ------------------------------------------------------------
  class LTS | initial : State, states : Set{State}, transitions : Set{Transition}, alphabet : Set{Id} .

  --- strong bisimulation as defined by R. Milner
  op bisim : Object Object -> Bool .
  op bisimRec : State State Object Object Set{State} Set{State} -> Bool .
  op noOutgoingTransitions : State Set{Transition} -> Bool .
  op outgoingTransitions : State Set{Transition} -> Bool .

  --- strong simulation, the first one is simulated by the second one
  op sim : Object Object -> Bool .
  op simRec : State State Object Object Set{State} -> Bool .
  op noMatchingTransition : State Set{Transition} Transition -> Bool .

  --- branching bisimulation as defined by R. van Glabbeek
  op tbisim : Object Object -> Bool .
  op tbisimRec : State State Object Object Set{State} Set{State} -> Bool .

  op ex1 : -> Object .
  op ex2 : -> Object .
  op ex3 : -> Object .
  op ex4 : -> Object .
  op ex5 : -> Object .
  op ex6 : -> Object .
  op ex7 : -> Object .
  op ex8 : -> Object .
  op ex9 : -> Object .
  op ex10 : -> Object .
  op ex11 : -> Object .

  vars LTS1 LTS2 : Oid .
  vars S S1 S11 S2 S22 : State .
  vars O O1 O2 : Object .
  vars T1 T2 T1' T2' Trs : Set{Transition} .
  vars L L1 L2 : Id .
  vars VIS1 VIS2 Sts : Set{State} .
  vars Trans : Transition .
  var  M : Map{State, Nat} .
  var  I I1 I2 : Nat .
  var  Str : String .

  ---- Takes an object representing an LTS and gives back a string with its AUT representation
  op toString : Object ~> String .
  op toString : Object String -> String .
  eq toString(< LTS1 : LTS | initial : S, states : (S, Sts), transitions : Trs >) 
   = toString(< LTS1 : LTS | states : Sts >, 
       "des(0, " + string(| Trs |, 10) + ", " + string(s s s | Sts |, 10) + ")") .
  eq toString(< LTS1 : LTS | transitions : (transition(state(I1), L, state(I2)), Trs) >, Str) 
   = toString(< LTS1 : LTS | transitions : Trs >, 
       Str + "\n" + "(" + string(I1, 10) + ", \"" + L + "\", " + string(I2, 10) + ")") .
  eq toString(< LTS1 : LTS | transitions : empty >, Str) = Str .

  --- strong bisimulation (equations)
  eq bisim(
       < LTS1 : LTS | initial : S1 >,
       < LTS2 : LTS | initial : S2 >
       )
     = bisimRec(S1, S2, < LTS1 : LTS | >, < LTS2 : LTS | >, empty, empty) .

  --- rule with matching transitions, recursive calls and one unvisited state
  ceq bisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1,
      VIS2
      )
    = bisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : (T1) >,
        < LTS2 : LTS | transitions : (T2) >,
        VIS1,
        VIS2
        )
        and
        bisimRec(S11, S22,
        < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
        < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
        (S1, VIS1),
        (S2, VIS2)
        )
    if not (S1 in VIS1 and S2 in VIS2) . --- at least one state has not been visited

  --- rule with matching transitions, but visited states
  ceq bisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1,
      VIS2
      )
    = true
    if (S1 in VIS1 and S2 in VIS2) . --- both target states already visited

  --- two states without outgoing transitions are bisimilar
  ceq bisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    = true
    if noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .

  eq bisimRec(S1, S2, O1, O2, VIS1, VIS2)
    = false [owise] .

  --- this operation checks whether one state does not have any outgoing transition
  eq noOutgoingTransitions(S1, (transition(S1, L, S11), T1))
    = false .
  eq noOutgoingTransitions(S1, T1)
    = true [owise] .

  --- this operation checks whether one state has any outgoing transition
  eq outgoingTransitions(S1, (transition(S1, L, S11), T1))
    = true .
  eq outgoingTransitions(S1, T1)
    = false [owise] .

  --- branching bisimulation (equations)
  eq tbisim(
       < LTS1 : LTS | initial : S1 >,
       < LTS2 : LTS | initial : S2 >
       )
     = tbisimRec(S1, S2, < LTS1 : LTS | >, < LTS2 : LTS | >, empty, empty) .

  --- rule with matching transitions, recursive call and one unvisited state
  ceq [tbisimRec-samelabel]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1,
      VIS2
      )
    = tbisimRec(  --- recursive call if both T1 and T2 are not empty
        S1,
        S2,
        < LTS1 : LTS | transitions : (T1) >,  --- TODO: remove transition ?
        < LTS2 : LTS | transitions : (T2) >,
        VIS1,
        VIS2
        )
        and
        tbisimRec(S11, S22,
        < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
        < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
        (S1, VIS1),
        (S2, VIS2)
        )
    if not (S1 in VIS1 and S2 in VIS2) /\ (L =/= "i") /\ outgoingTransitions(S1, T1) /\ outgoingTransitions(S2, T2) .
    --- at least one state has not been visited

  --- rule with matching transitions, NO recursive call and one unvisited state
  ceq [tbisimRec-samelabel-bis]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1,
      VIS2
      )
    = tbisimRec(S11, S22,
        < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
        < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
        (S1, VIS1),
        (S2, VIS2)
        )
    if not (S1 in VIS1 and S2 in VIS2) /\ (L =/= "i") /\ noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .
    --- at least one state has not been visited

  --- rules with tau action (skip) + rec. call -> for first LTS
  ceq [tbisimRec-tau1]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, "i", S11), T1) >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    = tbisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : (T1) >,
        < LTS2 : LTS | transitions : T2 >,
        VIS1,
        VIS2
        )
        and
        tbisimRec(S11, S2,
        < LTS1 : LTS | transitions : (transition(S1, "i", S11), T1) >,
        < LTS2 : LTS | transitions : T2 >,
        (S1, VIS1),
        VIS2
        )
    if not (S1 in VIS1) and outgoingTransitions(S1, T1) .

  --- rules with tau action (skip) + NO rec. call -> for first LTS
  ceq [tbisimRec-tau1-bis]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, "i", S11), T1) >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    = tbisimRec(S11, S2,
        < LTS1 : LTS | transitions : (transition(S1, "i", S11), T1) >,
        < LTS2 : LTS | transitions : T2 >,
        (S1, VIS1),
        VIS2
        )
    if not (S1 in VIS1) and noOutgoingTransitions(S1, T1) .

  --- rules with tau action (skip) + rec. call -> for second LTS
  ceq [tbisimRec-tau2]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : (transition(S2, "i", S22), T2) >,
      VIS1,
      VIS2
      )
    = tbisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : T1 >,
        < LTS2 : LTS | transitions : (T2) >,
        VIS1,
        VIS2
        )
        and
        tbisimRec(S1, S22,
        < LTS1 : LTS | transitions : T1 >,
        < LTS2 : LTS | transitions : (transition(S2, "i", S22), T2) >,
        VIS1,
        (S2, VIS2)
        )
    if not (S2 in VIS2) and outgoingTransitions(S2, T2) .

  --- rules with tau action (skip) + NO rec. call -> for second LTS
  ceq [tbisimRec-tau2-bis]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : (transition(S2, "i", S22), T2) >,
      VIS1,
      VIS2
      )
    = tbisimRec(S1, S22,
        < LTS1 : LTS | transitions : T1 >,
        < LTS2 : LTS | transitions : (transition(S2, "i", S22), T2) >,
        VIS1,
        (S2, VIS2)
        )
    if not (S2 in VIS2) and noOutgoingTransitions(S2, T2) .

  --- rule with matching transitions, but visited states
  ceq [tbisimRec-alreadyvisited]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1,
      VIS2
      )
    = true
    if (S1 in VIS1 and S2 in VIS2) . --- both target states already visited

  --- two states without outgoing transitions are bisimilar
  ceq [tbisimRec-noouttrans]: tbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    = true
    if noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .

  eq [tbisimRec-owise-false]: tbisimRec(S1, S2, O1, O2, VIS1, VIS2)
    = false [owise] .



  --- strong simulation (equations)
  eq sim(
       < LTS1 : LTS | initial : S1 >,
       < LTS2 : LTS | initial : S2 >
       )
     = simRec(S1, S2, < LTS1 : LTS | >, < LTS2 : LTS | >, empty) .

  --- rule with matching transitions, recursive calls and one unvisited state
  ceq simRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1
      )
    = simRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : (T1) >,
        < LTS2 : LTS | transitions : (T2) >,
        VIS1
        )
        and
        simRec(S11, S22,
        < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
        < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
        (S1, VIS1)
        )
    if not (S1 in VIS1) .

  --- rule with matching transitions, but already visited state
  ceq simRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1
      )
    = true
    if (S1 in VIS1) .

  --- states without outgoing transitions
  ceq simRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1
      )
    = true
    if noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .

  --- rule with additional transition in the second LTS
  --- (without any matching in the first LTS)
  ceq simRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1
      )
    = true
    if not (S1 in VIS1) /\ noMatchingTransition(S1, T1, transition(S2, L, S22)) .

  eq simRec(S1, S2, O1, O2, VIS1)
    = false [owise] .

  --- this operation checks whether a transition does not have any matching
  --- in a set of transitions

  eq noMatchingTransition(S1, (transition(S1, L, S11), T1), transition(S2, L, S22))
    = false .
  eq noMatchingTransition(S1, T1, Trans)
    = true [owise] .


----------------------------- strong bisimulation with non-determinism
  op ndbisim : Object Object -> Bool .
  op ndbisimRec : State State Object Object Set{State} Set{State} -> Bool . ----[memo] .

  eq ndbisim(
       < LTS1 : LTS | initial : S1 >,
       < LTS2 : LTS | initial : S2 >
       )
     = ndbisimRec(S1, S2, < LTS1 : LTS | >, < LTS2 : LTS | >, empty, empty) .

  --- rule with matching transitions, recursive calls and one unvisited state
  ceq ndbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1' >,
      < LTS2 : LTS | transitions : T2' >,
      VIS1,
      VIS2
      )
    = true
    if not (S1 in VIS1 and S2 in VIS2)  --- at least one state has not been visited
    /\ (transition(S1, L, S11), T1) := T1'
    /\ (transition(S2, L, S22), T2) := T2'
    /\ ndbisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : (T1) >,
        < LTS2 : LTS | transitions : (T2) >,
        VIS1,
        VIS2
        )
    /\ ndbisimRec(S11, S22,
        < LTS1 : LTS | >,
        < LTS2 : LTS | >,
        (S1, VIS1),
        (S2, VIS2)
        ) .

  --- rule with matching transitions, but visited states
  ceq ndbisimRec(
      S1,
      S2,
      < LTS1 : LTS | >,
      < LTS2 : LTS | >,
      VIS1,
      VIS2
      )
    = true
    if (S1 in VIS1 and S2 in VIS2) . --- both target states already visited

  --- two states without outgoing transitions are bisimilar
  ceq ndbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    = true
    if noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .

  eq ndbisimRec(S1, S2, O1, O2, VIS1, VIS2)
    = false [owise] .
-----------------------------
----------------------------- strong bisimulation with non-determinism (trying to accelerate the computation)
  op ndbisim1 : Object Object -> Bool .
  op ndbisimRec1 : State State Object Object Set{State} Set{State} -> Bool .

  eq ndbisim1(
       < LTS1 : LTS | initial : S1 >,
       < LTS2 : LTS | initial : S2 >
       )
     = ndbisimRec1(S1, S2, < LTS1 : LTS | >, < LTS2 : LTS | >, empty, empty) .

  --- rule with matching transitions, but visited states
  ceq ndbisimRec1(
      S1,
      S2,
      < LTS1 : LTS | >,
      < LTS2 : LTS | >,
      VIS1,
      VIS2
      )
    = true
    if S1 in VIS1 /\ S2 in VIS2 . --- both target states already visited

  --- two states without outgoing transitions are bisimilar
  ceq ndbisimRec1(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    = true
    if noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .

  --- rule with matching transitions, recursive calls and one unvisited state
  ceq ndbisimRec1(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1' >,
      < LTS2 : LTS | transitions : T2' >,
      VIS1,
      VIS2
      )
    = true
    if not (S1 in VIS1 and S2 in VIS2)  --- at least one state has not been visited
    /\ (transition(S1, L, S11), T1) := T1'
    /\ (transition(S2, L, S22), T2) := T2'
    /\ ndbisimRec1(S11, S22,
        < LTS1 : LTS | >,
        < LTS2 : LTS | >,
        (S1, VIS1),
        (S2, VIS2)
        ) 
    /\ ndbisimRec1(
        S1,
        S2,
        < LTS1 : LTS | transitions : (T1) >,
        < LTS2 : LTS | transitions : (T2) >,
        VIS1,
        VIS2
        )
    .

  eq ndbisimRec1(S1, S2, O1, O2, VIS1, VIS2)
    = false [owise] .
----------------------------- strong bisimulation with non-determinism
  op ndbisim2 : Object Object -> Bool .
  op ndbisimRec2 : State State Object Object Set{State} Set{State} -> Bool .

  eq ndbisim2(
       < LTS1 : LTS | initial : S1 >,
       < LTS2 : LTS | initial : S2 >
       )
     = ndbisimRec2(S1, S2, < LTS1 : LTS | >, < LTS2 : LTS | >, empty, empty) .

  --- rule with matching transitions, recursive calls and one unvisited state
  crl ndbisimRec2(
      S1,
      S2,
      < LTS1 : LTS | transitions : (transition(S1, L, S11), T1)  >,
      < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
      VIS1,
      VIS2
      )
   => ndbisimRec2(
        S1,
        S2,
        < LTS1 : LTS | transitions : (T1) >,
        < LTS2 : LTS | transitions : (T2) >,
        VIS1,
        VIS2
        )
      and-then 
      ndbisimRec2(S11, S22,
        < LTS1 : LTS | transitions : (transition(S1, L, S11), T1) >,
        < LTS2 : LTS | transitions : (transition(S2, L, S22), T2) >,
        (S1, VIS1),
        (S2, VIS2)
        )
    if not (S1 in VIS1 and S2 in VIS2)  --- at least one state has not been visited
    .

  --- rule with matching transitions, but visited states
  crl ndbisimRec2(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    => true
    if (S1 in VIS1 and S2 in VIS2) . --- both target states already visited

  --- two states without outgoing transitions are bisimilar
  crl ndbisimRec2(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    => true
    if noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .

----  eq ndbisimRec2(S1, S2, O1, O2, VIS1, VIS2)
----    = false [owise] .
-----------------------------

----------------------------- strong bisimulation with non-determinism and taus
  op ndtbisim(_,_) : Object Object -> Bool 
       [format(r o n++i o ni o o--)] .
  op ndtbisimRec(_,_,_,_,_,_) : State State Object Object Set{State} Set{State} -> Bool 
       [format(r o n++i o ni o ni o ni o ni o ni o o--)] .

  eq ndtbisim(
       < LTS1 : LTS | initial : S1 >,
       < LTS2 : LTS | initial : S2 >
       )
     = ndtbisimRec(S1, S2, < LTS1 : LTS | >, < LTS2 : LTS | >, empty, empty) .

  --- rule with matching transitions, recursive calls and one unvisited state
  ceq ndtbisimRec(
      S1,
      S2,
      < LTS1 : LTS | transitions : T1 >,
      < LTS2 : LTS | transitions : T2 >,
      VIS1,
      VIS2
      )
    = true
    if not (S1 in VIS1 and S2 in VIS2)  --- at least one state has not been visited
    /\ (transition(S1, L, S11), T1') := T1
    /\ (transition(S2, L, S22), T2') := T2 
    /\ ndtbisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : T1' >,
        < LTS2 : LTS | transitions : T2' >,
        VIS1,
        VIS2
        )
    /\ ndtbisimRec(S11, S22,
        < LTS1 : LTS | >,
        < LTS2 : LTS | >,
        (S1, VIS1),
        (S2, VIS2)
        ).

  --- rules with tau action (skip) + rec. call -> for first LTS
  ceq [tbisimRec-tau1]: 
      ndtbisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : (transition(S1, "i", S11), T1) >,
        < LTS2 : LTS | >,
        VIS1,
        VIS2
        )
    = true
    if not (S1 in VIS1) 
    /\ ndtbisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : T1 >,
        < LTS2 : LTS | >,
        VIS1,
        VIS2
        )
    /\ ndtbisimRec(
        S11, 
        S2,
        < LTS1 : LTS | >,
        < LTS2 : LTS | >,
        (S1, VIS1),
        VIS2
        ).

  --- rules with tau action (skip) + rec. call -> for second LTS
  ceq [tbisimRec-tau2]: 
      ndtbisimRec(
        S1,
        S2,
        < LTS1 : LTS | >,
        < LTS2 : LTS | transitions : (transition(S2, "i", S22), T2) >,
        VIS1,
        VIS2
        )
    = true
    if not (S2 in VIS2) 
    /\ ndtbisimRec(
        S1,
        S2,
        < LTS1 : LTS | >,
        < LTS2 : LTS | transitions : T2 >,
        VIS1,
        VIS2
        )
    /\ ndtbisimRec(
        S1, 
        S22,
        < LTS1 : LTS | >,
        < LTS2 : LTS | >,
        VIS1,
        (S2, VIS2)
        ) .

  --- rule with matching transitions, but visited states
  ceq ndtbisimRec(
        S1,
        S2,
        < LTS1 : LTS | >,
        < LTS2 : LTS | >,
        VIS1,
        VIS2
        )
    = true
    if (S1 in VIS1 and S2 in VIS2) . --- both target states already visited

  --- two states without outgoing transitions are bisimilar
  ceq ndtbisimRec(
        S1,
        S2,
        < LTS1 : LTS | transitions : T1 >,
        < LTS2 : LTS | transitions : T2 >,
        VIS1,
        VIS2
        )
    = true
    if noOutgoingTransitions(S1, T1) /\ noOutgoingTransitions(S2, T2) .

  eq ndtbisimRec(S1, S2, O1, O2, VIS1, VIS2)
    = false [owise] .
-----------------------------

  --- examples

  eq ex1 = < "lts1" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3), state(4)),
             transitions : (
               transition(state(1), "a", state(2)),
               transition(state(2), "b", state(3)),
               transition(state(3), "a", state(2)),
               transition(state(2), "c", state(4))
             ),
             alphabet : ("a", "b", "c") > .

  eq ex2 = < "lts2" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3), state(4), state(5), state(6)),
             transitions : (
               transition(state(1), "a", state(2)),
               transition(state(2), "b", state(3)),
               transition(state(3), "a", state(4)),
               transition(state(4), "b", state(3)),
               transition(state(2), "c", state(5)),
               transition(state(4), "c", state(6))
             ),
             alphabet : ("a", "b", "c") > .

  eq ex3 = < "lts3" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3)),
             transitions : (
               transition(state(1), "a", state(2)),
               transition(state(2), "b", state(3)),
               transition(state(3), "a", state(2))
             ),
             alphabet : ("a", "b") > .

  eq ex4 = < "lts4" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3), state(4)),
             transitions : (
               transition(state(1), "a", state(2)),
               transition(state(2), "b", state(3)),
               transition(state(3), "i", state(4)),
               transition(state(4), "a", state(2))
             ),
             alphabet : ("a", "b", "i") > .

  eq ex5 = < "lts5" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3)),
             transitions : (
               transition(state(1), "a", state(2)),
               transition(state(1), "b", state(3))
             ),
             alphabet : ("a", "b") > .

  eq ex6 = < "lts6" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3), state(4)),
             transitions : (
               transition(state(1), "i", state(2)),
               transition(state(2), "a", state(3)),
               transition(state(1), "b", state(4))
             ),
             alphabet : ("a", "b", "i") > .

  eq ex7 = < "lts7" : LTS
           | initial : state(0),
             states : (state(0), state(1), state(2), state(3)),
             transitions : (
               transition(state(0), "a", state(1)),
               transition(state(0), "b", state(1))
               ---transition(state(0), "a", state(2)),
               ---transition(state(2), "b", state(1)),
               ---transition(state(0), "b", state(3)),
               ---transition(state(3), "a", state(1))
             ),
             alphabet : ("a", "b") > .

  eq ex8 = < "lts8" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3), state(4), state(5), state(6), state(7), state(8), state(9), state(10), state(11)),
             transitions : (
               transition(state(1), "i", state(2)),
               ---transition(state(1), "i", state(3)),
               transition(state(1), "i", state(4)),
               transition(state(2), "a", state(5)),
               transition(state(5), "i", state(6)),
               ---transition(state(3), "i", state(7)),
               ---transition(state(7), "a", state(10)),
               ---transition(state(10), "b", state(11)),
               ---transition(state(7), "b", state(9)),
               ---transition(state(9), "a", state(11)),
               ---transition(state(11), "i", state(6)),
               transition(state(4), "b", state(8)),
               transition(state(8), "i", state(6))
             ),
             alphabet : ("a", "b", "i") > .

  eq ex9 = < "lts9" : LTS
           | initial : state(0),
             states : (state(0), state(1), state(2), state(3), state(4), state(5), state(6), state(7)),
             transitions : (
               transition(state(0), "i", state(1)),
               transition(state(1), "a", state(2)),
               transition(state(2), "b", state(7)),
               transition(state(7), "i", state(3)),
               transition(state(1), "i", state(4)),
               transition(state(4), "a", state(5)),
               transition(state(5), "c", state(6)),
               transition(state(6), "i", state(3))
             ),
             alphabet : ("a", "b", "c", "i") > .

  eq ex10 = < "lts10" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3), state(4), state(5)),
             transitions : (
               transition(state(1), "a", state(2)),
               transition(state(2), "c", state(3)),
               transition(state(1), "a", state(4)),
               transition(state(4), "b", state(3))
             ),
             alphabet : ("a", "b", "c") > .

  eq ex11 = < "lts11" : LTS
           | initial : state(1),
             states : (state(1), state(2), state(3), state(4), state(5)),
             transitions : (
               transition(state(1), "a", state(2)),
               transition(state(2), "b", state(3)),
               transition(state(1), "a", state(4)),
               transition(state(4), "c", state(3))
             ),
             alphabet : ("a", "b", "c") > .
endom

eof
set trace on .
set trace select on .
trace select ---- tbisim 
             ---- tbisimRec 
             ndtbisim`(_`,_`)
             ndtbisimRec`(_`,_`,_`,_`,_`,_`)
             .

---(
eof
rew bisim(ex1, ex2) . --- expected true
rew bisim(ex1, ex3) . --- expected false
rew bisim(ex3, ex4) . --- expected false

rew sim(ex1, ex3) .   --- expected false
rew sim(ex3, ex1) .   --- expected true
rew sim(ex1, ex1) .   --- expected true

rew tbisim(ex3, ex4) . --- expected true
rew tbisim(ex5, ex6) . --- expected true

rew tbisim(ex9, ex10) . --- expected true

rew tbisim(ex7, ex8) . --- expected true

rew bisim(ex10,ex10) . --- expected true
rew bisim(ex10,ex11) . --- expected false

rew ndbisim(ex10,ex10) . --- expected true
rew ndbisim(ex10,ex11) . --- expected false
) 

red ndtbisim(ex7, ex8) .  --- expected true

eof
rew ndtbisim(ex9, ex10) . --- expected true
rew ndtbisim(ex10,ex10) . --- expected true
rew ndtbisim(ex10,ex11) . --- expected false
